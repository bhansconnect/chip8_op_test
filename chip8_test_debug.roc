app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.17.0/lZFLstMUCUvd5bjnnpYromZJXkQUrdhbva4xdBInicE.tar.br" }

import pf.Stdout
import pf.Task

width = 64
height = 32

romData : List(U8)
romData = [
    0x12, 0x4e, 0xea, 0xac, 0xaa, 0xea, 0xce, 0xaa, 0xaa, 0xae, 0xe0, 0xa0, 0xa0, 0xe0, 0xc0, 0x40,
    0x40, 0xe0, 0xe0, 0x20, 0xc0, 0xe0, 0xe0, 0x60, 0x20, 0xe0, 0xa0, 0xe0, 0x20, 0x20, 0x60, 0x40,
    0x20, 0x40, 0xe0, 0x80, 0xe0, 0xe0, 0xe0, 0x20, 0x20, 0x20, 0xe0, 0xe0, 0xa0, 0xe0, 0xe0, 0xe0,
    0x20, 0xe0, 0x40, 0xa0, 0xe0, 0xa0, 0xe0, 0xc0, 0x80, 0xe0, 0xe0, 0x80, 0xc0, 0x80, 0xa0, 0x40,
    0xa0, 0xa0, 0xa2, 0x02, 0xda, 0xb4, 0x00, 0xee, 0xa2, 0x02, 0xda, 0xb4, 0x13, 0xdc, 0x68, 0x01,
    0x69, 0x05, 0x6a, 0x0a, 0x6b, 0x01, 0x65, 0x2a, 0x66, 0x2b, 0xa2, 0x16, 0xd8, 0xb4, 0xa2, 0x3e,
    0xd9, 0xb4, 0xa2, 0x02, 0x36, 0x2b, 0xa2, 0x06, 0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x1a, 0xd8, 0xb4,
    0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x45, 0x2a, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x0b, 0xa2, 0x1e,
    0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x55, 0x60, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x10,
    0xa2, 0x26, 0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x76, 0xff, 0x46, 0x2a, 0xa2, 0x02,
    0xda, 0xb4, 0x6b, 0x15, 0xa2, 0x2e, 0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0xa2, 0x06, 0x95, 0x60,
    0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x1a, 0xa2, 0x32, 0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0x22, 0x42,
    0x68, 0x17, 0x69, 0x1b, 0x6a, 0x20, 0x6b, 0x01, 0xa2, 0x0a, 0xd8, 0xb4, 0xa2, 0x36, 0xd9, 0xb4,
    0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x0a, 0xd9, 0xb4, 0xa2, 0x06,
    0x87, 0x50, 0x47, 0x2a, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x0b, 0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x0e,
    0xd9, 0xb4, 0xa2, 0x06, 0x67, 0x2a, 0x87, 0xb1, 0x47, 0x2b, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x10,
    0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x12, 0xd9, 0xb4, 0xa2, 0x06, 0x66, 0x78, 0x67, 0x1f, 0x87, 0x62,
    0x47, 0x18, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x15, 0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x16, 0xd9, 0xb4,
    0xa2, 0x06, 0x66, 0x78, 0x67, 0x1f, 0x87, 0x63, 0x47, 0x67, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x1a,
    0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x1a, 0xd9, 0xb4, 0xa2, 0x06, 0x66, 0x8c, 0x67, 0x8c, 0x87, 0x64,
    0x47, 0x18, 0xa2, 0x02, 0xda, 0xb4, 0x68, 0x2c, 0x69, 0x30, 0x6a, 0x34, 0x6b, 0x01, 0xa2, 0x2a,
    0xd8, 0xb4, 0xa2, 0x1e, 0xd9, 0xb4, 0xa2, 0x06, 0x66, 0x8c, 0x67, 0x78, 0x87, 0x65, 0x47, 0xec,
    0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x06, 0xa2, 0x2a, 0xd8, 0xb4, 0xa2, 0x22, 0xd9, 0xb4, 0xa2, 0x06,
    0x66, 0xe0, 0x86, 0x6e, 0x46, 0xc0, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x0b, 0xa2, 0x2a, 0xd8, 0xb4,
    0xa2, 0x36, 0xd9, 0xb4, 0xa2, 0x06, 0x66, 0x0f, 0x86, 0x66, 0x46, 0x07, 0xa2, 0x02, 0xda, 0xb4,
    0x6b, 0x10, 0xa2, 0x3a, 0xd8, 0xb4, 0xa2, 0x1e, 0xd9, 0xb4, 0xa3, 0xe8, 0x60, 0x00, 0x61, 0x30,
    0xf1, 0x55, 0xa3, 0xe9, 0xf0, 0x65, 0xa2, 0x06, 0x40, 0x30, 0xa2, 0x02, 0xda, 0xb4, 0x6b, 0x15,
    0xa2, 0x3a, 0xd8, 0xb4, 0xa2, 0x16, 0xd9, 0xb4, 0xa3, 0xe8, 0x66, 0x89, 0xf6, 0x33, 0xf2, 0x65,
    0xa2, 0x02, 0x30, 0x01, 0xa2, 0x06, 0x31, 0x03, 0xa2, 0x06, 0x32, 0x07, 0xa2, 0x06, 0xda, 0xb4,
    0x6b, 0x1a, 0xa2, 0x0e, 0xd8, 0xb4, 0xa2, 0x3e, 0xd9, 0xb4, 0x12, 0x48, 0x13, 0xdc,
]

State : {
    ram : List(U8),
    display : List(U8),
    regs : List(U8),
    stack : List(U16),
    sp : U64,
    pc : U64,
    lastPc : U64,
    addressReg : U64,
}

listRange : U64 -> List(U64)
listRange = |endVal| List.range { start: At 0, end: Before endVal }

listRepeat : U8, U64 -> List(U8)
listRepeat = |val, count| List.repeat val count

listRepeatU16 : U16, U64 -> List(U16)
listRepeatU16 = |val, count| List.repeat val count

screenString : List(U8) -> Str
screenString = |display| {
    indices = listRange (height * width)
    indices
        |> List.walk "\n" |str, i| {
            pixelResult = display |> List.get i
            pixel = Result.withDefault pixelResult 0
            char = if pixel != 0 "█" else "░"
            newStr = str |> Str.concat char
            if Num.rem (i + 1) width == 0 then
                newStr |> Str.concat "\n"
            else
                newStr
        }
}

initState : U8 -> State
initState = |iter| {
    emptyRam = listRepeat 0 4096
    ramWithIter = emptyRam |> List.set 0x199 iter
    ramWithRom = romData |> List.walkWithIndex ramWithIter |ram, byte, index| {
        ram |> List.set (0x200 + index) byte
    }
    {
        ram: ramWithRom,
        display: listRepeat 0 (width * height),
        regs: listRepeat 0 16,
        stack: listRepeatU16 0 12,
        sp: 0,
        pc: 0x200,
        lastPc: 0x0,
        addressReg: 0x0,
    }
}

step : State -> State
step = |state| {
    byte1 = Result.withDefault (state.ram |> List.get state.pc) 0
    byte2 = Result.withDefault (state.ram |> List.get (state.pc + 1)) 0
    opcode = Num.bitwiseOr (Num.shiftLeftBy (Num.toU64 byte1) 8) (Num.toU64 byte2)
    newState = { state & lastPc: state.pc, pc: state.pc + 2 }

    when Num.shiftRightBy opcode 12 is
        0x0 =>
            when opcode is
                0x0E0 =>
                    { newState & display: listRepeat 0 (width * height) }

                0x0EE => {
                    newSp = newState.sp - 1
                    newPc = Result.withDefault (newState.stack |> List.get newSp) 0
                    { newState & sp: newSp, pc: Num.toU64 newPc }
                }

                _ =>
                    newState

        0x1 =>
            { newState & pc: Num.bitwiseAnd opcode 0x0FFF }

        0x2 => {
            newStack = newState.stack |> List.set newState.sp (Num.toU16 newState.pc)
            { newState & stack: newStack, sp: newState.sp + 1, pc: Num.bitwiseAnd opcode 0x0FFF }
        }

        0x3 => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            x = Num.toU64 (Result.withDefault (newState.regs |> List.get xIdx) 0)
            kk = Num.bitwiseAnd opcode 0xFF
            pcInc = if x == kk then 2 else 0
            { newState & pc: newState.pc + pcInc }
        }

        0x4 => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            x = Num.toU64 (Result.withDefault (newState.regs |> List.get xIdx) 0)
            kk = Num.bitwiseAnd opcode 0xFF
            pcInc = if x != kk then 2 else 0
            { newState & pc: newState.pc + pcInc }
        }

        0x5 => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            yIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x00F0) 4
            x = Result.withDefault (newState.regs |> List.get xIdx) 0
            y = Result.withDefault (newState.regs |> List.get yIdx) 0
            pcInc = if x == y then 2 else 0
            { newState & pc: newState.pc + pcInc }
        }

        0x6 => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            kk = Num.toU8 (Num.bitwiseAnd opcode 0xFF)
            newRegs = newState.regs |> List.set xIdx kk
            { newState & regs: newRegs }
        }

        0x7 => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            x = Num.toU64 (Result.withDefault (newState.regs |> List.get xIdx) 0)
            kk = Num.bitwiseAnd opcode 0xFF
            newVal = Num.toU8 (Num.bitwiseAnd (x + kk) 0xFF)
            newRegs = newState.regs |> List.set xIdx newVal
            { newState & regs: newRegs }
        }

        0xD => {
            xIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x0F00) 8
            yIdx = Num.shiftRightBy (Num.bitwiseAnd opcode 0x00F0) 4
            xReg = Num.toU64 (Result.withDefault (newState.regs |> List.get xIdx) 0)
            yReg = Num.toU64 (Result.withDefault (newState.regs |> List.get yIdx) 0)
            x = Num.rem xReg width
            y = Num.rem yReg height
            n = Num.bitwiseAnd opcode 0x000F

            result =
                listRange n
                |> List.walk { display: newState.display, vf: 0 } |acc, rowOffset| {
                    row = y + rowOffset
                    if row >= height then
                        acc
                    else
                        spriteByte = Result.withDefault (newState.ram |> List.get (newState.addressReg + rowOffset)) 0
                        listRange 8
                        |> List.walk acc |innerAcc, colOffset| {
                            col = x + colOffset
                            if col >= width then
                                innerAcc
                            else
                                bitIndex = colOffset
                                mask = Num.shiftRightBy 0x80 bitIndex
                                pixel = Num.shiftRightBy (Num.bitwiseAnd spriteByte mask) (7 - bitIndex)
                                offset = col + row * width
                                currentPixel = Result.withDefault (innerAcc.display |> List.get offset) 0
                                newVf = Num.bitwiseOr innerAcc.vf (Num.bitwiseAnd currentPixel pixel)
                                newPixel = Num.bitwiseXor currentPixel pixel
                                newDisplay = innerAcc.display |> List.set offset newPixel
                                { display: newDisplay, vf: newVf }
                        }
                }

            regsWithVf = newState.regs |> List.set 0xF result.vf
            { newState & display: result.display, regs: regsWithVf }
        }

        _ =>
            newState
}

runEmulator : State -> State
runEmulator = |state| {
    if state.pc == state.lastPc then
        state
    else
        runEmulator (step state)
}

main =
    state = initState 0
    finalState = runEmulator state
    out = screenString finalState.display
    Stdout.line! out
